## 사용 이유

- 변수의 scope를 벗어난 경우에도 데이터를 공유할 수 있는 방법

## 메모리

- 데이터가 저장된 위치, 주소 값으로 식별 가능
- 주소 값은 바이트마다 할당됨
- 주소를 가리키는 포인터의 크기는 몇 시스템에 따라 다름
    - 32bit 시스템 → 포인터가 32bit = 포인터 크기가 4byte
    - 64bit 시스템 → 포인터가 64bit = 포인터 크기가 8byte
- 포인터의 크기가 크면, 표현할 수 있는 주소의 수가 늘어난다.
    - 32bit 시스템 - 2^32바이트의 주소 = 4GB.  4GB의 메인 메모리를 쓸 수 있음
    - 64bit 시스템 - 2^64바이트의 주소 = 16EB (엑사 바이트)
    - **즉. 64bit 시스템은 RAM을 16EB까지 커버 가능**. (시중에 TB 단위 RAM이 나옴)

## 문법

### 기본 문법

```c
int a;

int *pa; // 변수명 앞에 *(포인터 표시) 를 붙여 포인터를 선언
int * pa; //포인터가 '가리킬' 자료형을 앞에 선언해준다.
int* pa; //모두 같은 뜻

pa = &a; // &(주소 연산자) 로 a의 주소를 구하여 포인터에 대입 (pa->a)
*pa = 10; //  *(간접참조 연산자) 로 주소값에 간접적으로 접근하여 값을 대입

*pa // 변수처럼 l-value(저장공간), r-value(값) 으로 모두 이용가능.
```

- **`*`**   간접 참조 연산자 = 포인터 연산자

### 연산

```c
int a,b;
int *pa, *pb; 

pa = &a;  //연산 전에 반드시, 초기화를 해주는 것이 좋다.
pa = &b;

printf("%p", &a); //a의 주소를 출력함. p는 32bit, 64bit 상관없이 맞춰서 주소를 출력.
printf("%p", pa); //같은 주소를 가리키므로 위와 같은 결과

a=10;  //포인터는 참조이므로, 대입 이후에 a값을 바꿔줘도 *pa에 반영된다.
b=20;

*pa = *pa + *pb; //*pa 는 왼쪽에서는 저장공간으로, 오른쪽에서는 값으로 쓰였다.
```

- **포인터 초기화 필수**!
- 주소값은 **%p 로 출력**하는 것이 좋다.시스템에 따라 크기가 다를 수 있기 때문에
- 포인터도 같은 데이터 형끼리만 연산해야 한다.
    - 포인터 자체의 크기는 모두 같지만 (32bit: 4바이트, 64bit: 8바이트) 포인터 연산 시, 가리키는 데이터의 크기를 기준으로 연산되므로.
    - void 포인터끼리는 연산할 수 없다.(자료형의 크기가 정해져 있지 않아, 얼마나 이동할지 알 수 없기 때문에)

### 포인터의 대입 규칙

- 가리키는 변수의 형태가 같을 때만 대입해야 한다.
    - 주소 크기가 달라지면서 값 해석을 다르게 함 (overflow가 되거나, 데이터가 쪼개질 수 있음)
- 형 변환을 사용한 포인터의 대입은 언제든 가능

```c
int a,b;
int *pa = &a, *pb=&b;
double c;
double *pc=&c;

pc = pa; //컴파일 경고. (컴파일 에러는 안 남)
pc = (double *)pa; // 형 변환으로 타입 맞춰주면 경고는 안남. 하지만 결과는 같음.
```

- `pi = (int *)pd` 와 같은 코드는 pd의 앞쪽 2바이트만 접근하게 하는 ‘**데이터를 쪼개 쓰는**’ 접근이기 때문에 데이터가 메모리에 저장되는 방식을 충분히 이해하고 써야 한다.
- 포인터 주소를 직접 지정할 수도 있다?
    
    ```c
    int *p
    p=(int *)100;  //형변환으로 숫자 100을 int형 포인터로 변환해 직접 주소 지정가능
    *p = 10;
    ```
    
    - 권장 사항은 아니다.
    - 같은 원리로 **초기화도 안하면 위험하다**! → 엉뚱한 주소로 접근하게됨
- `(int *)` 와  `(int) *` 의 차이
    - `(int *)` : int를 가리키는 **포인터형으로 변환**시킴
    - `(int) *` :포인터가 가리키는 **값을 int형으로 변환**시킴
    - 확잌 코드
        
        ```c
        #include <stdio.h>
        
        int main() {
        
          double a=10.1;
          double *pa=&a;
        
          printf("%d\n",*(int *)pa); //858993459
          printf("%d\n",(int)*pa); //10
        
          return 0;
        }
        ```
        

### const  포인터

- 가리키는 값을 간접참조연산자를 통해 바꾸지 못한다.
    - `*pa = 20` 처럼 포인터를 통한 값 바꾸기를 못함
    - 변수 자체의 값 변경, 참조하는 주소 변경은 가능

```c
int a = 10, b=20;
const int *pa = &a; //const point 선언

a = 15;  //const포인터가 가리키는지 여부와 상관 없이 값 변경 가능.
pa = &b;  //변수 const와 달리 참조는 바꿀 수 있다.
*pa = 10; //불가능.(컴파일 에러) 간접참조연산자(*)를 통한 값 변경 불가능
```

- **사용하는 이유**
    - **문자열 상수를 인수로 받는 함**수 - 함수의 매개변수를 통해 값을 바꿀 수 없도록 const로 지정.
    - 즉. 함수 내부에서 값을 바꿀 수 없음
    - 사용하면 좋은 점
        - **데이터 보호, 컴파일 경고** - 다른 부분에서 변경 막음. 잠재적 문제 방지
            - 주니어가 실수로 값 못 바꾸게!
        - **API, 설계, 문서화 측면** - 다른 개발자들에게 해당 포인터가 변경되지 않음을 명확하게 전달 가능
        - **메모리 최적화** - 컴파일러가 최적화 작업시 메모리에 대한 추가 복사를 방지할 수 있음

## 주소와 포인터

- 주소는 ‘상수’, 포인터는’변수’
- 가리키는 자료형과 상관없이 크기가 같다.
    
    ```c
    char c;
    char *pc=&a;
    
    sizeof(c);  //1바이트
    sizeof(*pc); //1바이트. 위와 같음
    sizeof(&pc); //32bit; 4바이트, 64bit; 8바이트
    sizeof(pc); //32bit; 4바이트, 64bit; 8바이트  -> 포인터도 주소를 저장하므로, 위와 같음
    ```

## **포인터 활용**

- 함수 간에 효과적으로 데이터를 공유함
- 임베디드 프로그래밍시 메모리에 직접 접근
- 동적 할당한 메모리를 사용하는 경우

### **포인터 활용 예**

- 함수 안에서 두 값 바꾸기 (포인터 없이는 불가능함)
- 함수에 문자열 넘겨주기 (by Ref)